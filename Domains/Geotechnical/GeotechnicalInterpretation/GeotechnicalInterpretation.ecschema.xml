<?xml version="1.0" encoding="UTF-8"?>
<ECSchema schemaName="GeotechnicalInterpretation" alias="GeoInterp" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2" displayLabel="Geotechnical Interpretation" description="The GeotechnicalInterpretation schema defines classes that represent data for interpreting the earth's subterranean structure based on limited geotechnical exploration.">
    <ECSchemaReference name="AecUnits" version="01.00.03" alias="AECU"/>
    <ECSchemaReference name="Analytical" version="01.00.00" alias="anlyt" />
    <ECSchemaReference name="BisCore" version="01.00.10" alias="bis" />
    <ECSchemaReference name="CoreCustomAttributes" version="01.00.03" alias="CoreCA"/>
    <ECSchemaReference name="GeotechnicalExploration" version="01.00.00" alias="GeoExp" />

    <ECCustomAttributes>
        <ProductionStatus xmlns="CoreCustomAttributes.01.00.03">
            <SupportedUse>NotForProduction</SupportedUse>
        </ProductionStatus>
    </ECCustomAttributes>

    <!-- ==================== CORE INFORMATION HIERARCHY CLASSES ==================== -->

    <ECEntityClass typeName="GeotechnicalInterpretationPartition" modifier="Sealed" displayLabel="Geotechnical Interpretation Partition" description="GeotechnicalInterpretationPartition element indicates that there is a specialized Geotechnical Interpretation perspective for the parent Subject. " >
        <BaseClass>anlyt:AnalyticalPartition</BaseClass>
    </ECEntityClass>

    <ECEntityClass typeName="GeotechnicalInterpretationModel" modifier="Sealed" displayLabel="Geotechnical Interpretation Model" description="Model containing elements related to Geotechnical Interpretations." >
        <BaseClass>anlyt:AnalyticalModel</BaseClass>
    </ECEntityClass>

    <ECEntityClass typeName="GeotechnicalInterpretationElement" modifier="Abstract" displayLabel="Geotechnical Interpretation Element" description="Abstract superclass for all spatially-located Geotechnical Interpretation classes.">
        <BaseClass>anlyt:AnalyticalElement</BaseClass>
    </ECEntityClass>

    <ECEntityClass typeName="GeotechnicalInformationElement" modifier="Abstract" displayLabel="Geotechnical Information Element" description="Abstract superclass for all non-spatially-located Geotechnical Interpretation classes.">
        <BaseClass>bis:InformationRecordElement</BaseClass>
    </ECEntityClass>

    <ECEntityClass typeName="Interpretation" modifier="Sealed" displayLabel="Interpretation" description="A geotechnical interpretation of a region of the earth's subsurface. Interpretations always have a GeotechnicalInterpretationModel submodel.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <BaseClass>bis:ISubModeledElement</BaseClass>

        <ECNavigationProperty propertyName="Configuration" relationshipName="InterpretationHasConfiguration" direction="Forward" description="Reference to GeotechnicalInterpretationConfiguration that is used by this Interpretation."/>

        <!-- Add Bounds? -->
    </ECEntityClass>


    <!-- ==================== CONFIGURATION (DEFINITION MODEL) RELATED CLASSES ==================== -->

    <ECEntityClass typeName="GeotechnicalInterpretationConfiguration" modifier="Sealed" displayLabel="Geotechnical Interpretation Configuration" description="The configuration for one or more GeoExp:Interpretation.">
        <BaseClass>Bis:DefinitionContainer</BaseClass>
    </ECEntityClass>

    <ECRelationshipClass typeName="InterpretationHasConfiguration" strength="referencing" modifier="Sealed" description="Relationship to define that a specific GeoInterp:Interpretation has a configuration of GeoInterp:GeotechnicalInterpretationConfiguration.">
        <Source multiplicity="(0..*)" roleLabel="has configuration" polymorphic="false">
            <Class class="Interpretation" />
        </Source>
        <Target multiplicity="(1..1)" roleLabel="is configuration for" polymorphic="false">
            <Class class="GeotechnicalInterpretationConfiguration"/>
        </Target>
    </ECRelationshipClass>

    <ECEntityClass typeName="InvestigationMapping" displayLabel="Investigation Mapping" modifier="Sealed" description="A mapping from a GeoExp:GeotechnicalInvestigationConfiguration to a GeoInterp:GeotechnicalInterpretationConfiguration.">
        <BaseClass>bis:DefinitionElement</BaseClass>   
        <ECProperty           propertyName="MaterialMappedClass"     typeName="string" displayLabel="Material Mapped Class"   description="Identifies the GeoExp:ILithology subclass that maps to GeoInterp:Material"/>

        <ECNavigationProperty propertyName="MappedConfiguration"    relationshipName="InvestigationMappingMapsInvestigationConfiguration"   direction="Forward" description="Reference to GeoExp:GeotechnicalInvestigationConfiguration that is being mapped."/>
   </ECEntityClass>

    <ECRelationshipClass typeName="InvestigationMappingMapsInvestigationConfiguration" strength="referencing" modifier="Sealed" description="Relationship to define that a specific GeoInterp:InvestigationMapping maps a GeoExp:GeotechnicalInvestigationConfiguration.">
        <Source multiplicity="(0..*)" roleLabel="maps" polymorphic="false">
            <Class class="InvestigationMapping" />
        </Source>
        <Target multiplicity="(1..1)" roleLabel="is mapped by" polymorphic="true">
            <Class class="GeoExp:GeotechnicalInvestigationConfiguration"/>
        </Target>
    </ECRelationshipClass>

    <ECEntityClass typeName="IMaterial" modifier="Abstract" displayLabel="IMaterial" description="A geotechnical material, uniform for the purposes of the interpretation.">
        <ECCustomAttributes>
            <IsMixin xmlns="CoreCustomAttributes.01.00.00">
                <AppliesToEntityClass>bis:DefinitionElement</AppliesToEntityClass>
            </IsMixin>
        </ECCustomAttributes>
    </ECEntityClass>

    <ECEntityClass typeName="Material" displayLabel="Material" modifier="Sealed" description="A geotechnical material, from the lithography perspective (boring logs, etc.).">
        <BaseClass>bis:DefinitionElement</BaseClass>   
        <BaseClass>IMaterial</BaseClass>   
    </ECEntityClass>

    <ECEntityClass typeName="AliasMaterial" displayLabel="AliasMaterial" modifier="Sealed" description="An IMaterial that is an alias for a Material.">
        <BaseClass>bis:DefinitionElement</BaseClass>   
        <BaseClass>IMaterial</BaseClass>

        <ECNavigationProperty propertyName="AliasFor" relationshipName="AliasMaterialRenamesMaterial" direction="Forward" description="Required reference to the Material being renamed."/>
    </ECEntityClass>

    <ECRelationshipClass typeName="AliasMaterialRenamesMaterial" strength="referencing" modifier="Sealed" description="Relates an AliasMaterial to the Material it renames.">
        <Source multiplicity="(0..*)" roleLabel="renames" polymorphic="false">
            <Class class="AliasMaterial" />
        </Source>
        <Target multiplicity="(0..1)" roleLabel="is renamed as" polymorphic="false">
            <Class class="Material" />
        </Target>
    </ECRelationshipClass>

    <!-- Abstract Material Mapping Relationship (in case we need it) -->
    <ECRelationshipClass typeName="LithologyMapsToMaterial" strength="referencing" modifier="Abstract" description="Maps GeoExp:ILithology to the GeoInterp:Material that represents that material." >
        <BaseClass>bis:ElementRefersToElements</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="maps to" polymorphic="true">
            <Class class="GeoExp:ILithology"/>
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is mapped from" polymorphic="false">
            <Class class="Material"/>
        </Target>
    </ECRelationshipClass>

    <!-- LegendCode-to-Material Mapping -->
    <ECRelationshipClass typeName="LegendCodeMapsToMaterial" strength="referencing" modifier="Sealed" description="Maps a GeoExp:LegendCode to a GeoInterp:Material." >
        <BaseClass>LithologyMapsToMaterial</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="maps to" polymorphic="true">
            <Class class="GeoExp:LegendCode"/>
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is mapped to" polymorphic="false">
            <Class class="Material"/>
        </Target>
    </ECRelationshipClass>

    <!-- UscsCode-to-Material Mapping -->
    <!-- TBD -->

    <!-- GeologyCode-to-Material Mapping -->
    <ECRelationshipClass typeName="GeologyCodeMapsToMaterial" strength="referencing" modifier="Sealed" description="Maps a GeoExp:GeologyCode to a GeoInterp:Material." >
        <BaseClass>LithologyMapsToMaterial</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="maps to" polymorphic="true">
            <Class class="GeoExp:GeologyCode"/>
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is mapped to" polymorphic="false">
            <Class class="Material"/>
        </Target>
    </ECRelationshipClass>


    <!-- AlternateGeologyCode-to-Material Mapping -->
    <ECRelationshipClass typeName="AlternateGeologyCodeMapsToMaterial" strength="referencing" modifier="Sealed" description="Maps a GeoExp:AlternateGeologyCode to a GeoInterp:Material." >
        <BaseClass>LithologyMapsToMaterial</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="maps to" polymorphic="true">
            <Class class="GeoExp:AlternateGeologyCode"/>
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is mapped to" polymorphic="false">
            <Class class="Material"/>
        </Target>
    </ECRelationshipClass>


    <!-- ==================== BoreholeCollection-RELATED CLASSES ==================== -->

    <ECEntityClass typeName="IBoreholeCollection" modifier="Abstract" displayLabel="Borehole Collection" description="An interface that defines collections of Boreholes.">
        <ECCustomAttributes>
            <IsMixin xmlns="CoreCustomAttributes.01.00.03">
                <AppliesToEntityClass>GeotechnicalInterpretationElement</AppliesToEntityClass>
            </IsMixin>
        </ECCustomAttributes>
        <BaseClass>IOperand</BaseClass>
    </ECEntityClass>

    <!-- ==================== BoreholeGroup-RELATED CLASSES ==================== -->

    <ECEntityClass typeName="BoreholeGroup" modifier="Sealed" displayLabel="Borehole Group" description="A non-exclusive collection of Boreholes.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <BaseClass>IBoreholeCollection</BaseClass>
    </ECEntityClass>

    <ECRelationshipClass typeName="BoreholeGroupIncludesBorehole" strength="referencing" modifier="Sealed" description="Includes a Borehole into a BoreholeGroup" >
        <BaseClass>bis:ElementRefersToElements</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="includes" polymorphic="false">
            <Class class="BoreholeGroup"/>
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is included in" polymorphic="false">
            <Class class="Borehole"/>
        </Target>
    </ECRelationshipClass>

    <!-- ==================== BoreholeSource-RELATED CLASSES ==================== -->

    <ECEntityClass typeName="BoreholeSource" modifier="Sealed" displayLabel="Borehole Source" description="An exclusive collection of Boreholes.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <BaseClass>IBoreholeCollection</BaseClass>

        <ECNavigationProperty propertyName="DerivedFrom" relationshipName="BoreholeSourceIsDerivedFromInvestigationElement" direction="Forward" description="Optional reference to GeoExp:GeotechnicalInvestigationElement that is source for this BoreholeSource."/>
    </ECEntityClass>

    <ECRelationshipClass typeName="BoreholeSourceIsDerivedFromInvestigationElement" strength="referencing" modifier="Sealed" description="Relates a BoreholeSource to the GeoExp:GeotechnicalInvestigationElement it was derived from.">
        <Source multiplicity="(0..*)" roleLabel="is derived from" polymorphic="false">
            <Class class="BoreholeSource" />
        </Source>
        <Target multiplicity="(0..1)" roleLabel="is source for" polymorphic="true">
            <Class class="GeoExp:GeotechnicalInvestigationElement" />
        </Target>
    </ECRelationshipClass>

    <ECRelationshipClass typeName="BoreholeSourceOwnsBoreholes" strength="embedding" modifier="Sealed">
        <BaseClass>bis:ElementOwnsChildElements</BaseClass>
        <Source multiplicity="(1..1)" polymorphic="false" roleLabel="owns">
            <Class class="BoreholeSource"/>
        </Source>
        <Target multiplicity="(0..*)" polymorphic="false" roleLabel="is owned by">
            <Class class="Borehole"/>
        </Target>
    </ECRelationshipClass>

    <!-- ==================== BOREHOLE-RELATED CLASSES ==================== -->

    <!-- Note that Borehole is NOT an IOperand (IBoreCollection should be used as the IOperand instead) -->
    <ECEntityClass typeName="Borehole" modifier="Sealed" displayLabel="Borehole" description="A borehole or other investigation producing data similar to borehole logs.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>

        <ECProperty propertyName="Active"   displayLabel="Active"   typeName="bool"                              description="This Borehole should be considered in calculations."/>
        <ECProperty propertyName="Location" displayLabel="Location" typeName="Bentley.Geometry.Common.IGeometry" description="The path of the Borehole from the surface downward."/>

        <ECNavigationProperty propertyName="DerivedFrom" relationshipName="BoreholeIsDerivedFromExploratoryLocation" direction="Forward" description="Optional reference to GeoExp:ExploratoryLocation that is source for this Borehole."/>
    </ECEntityClass>

    <ECRelationshipClass typeName="BoreholeIsDerivedFromExploratoryLocation" strength="referencing" modifier="Sealed" description="Relates a Borehole to the GeoExp:ExploratoryLocation it was derived from.">
        <Source multiplicity="(0..*)" roleLabel="is derived from" polymorphic="false">
            <Class class="Borehole" />
        </Source>
        <Target multiplicity="(0..1)" roleLabel="is source information for" polymorphic="true">
            <Class class="GeoExp:ExploratoryLocation" />
        </Target>
    </ECRelationshipClass>

    <!-- Note that MaterialDepthRange is NOT an IOperand (Borehole should be used as the IOperand instead) -->
    <ECEntityClass typeName="MaterialDepthRange" modifier="Sealed" displayLabel="Material Depth Range" description="A contiguous portion of a Borehole with a constant Material. Always parented by Borehole.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>

        <ECProperty propertyName="Location"  typeName="Bentley.Geometry.Common.IGeometry" displayLabel="Location"     kindOfQuantity="AECU:LENGTH" description="The location this MaterialDepthRange (portion of the parent Borehole path)."/>
        <ECProperty propertyName="DepthTop"  typeName="double"                            displayLabel="Top Depth"    kindOfQuantity="AECU:LENGTH" description="Distance from ground surface to top of depth range." />
        <ECProperty propertyName="DepthBase" typeName="double"                            displayLabel="Bottom Depth" kindOfQuantity="AECU:LENGTH" description="Distance from ground surface to bottom of depth range."/>

        <ECNavigationProperty propertyName="Material" relationshipName="MaterialDepthRangeHasMaterial" direction="Forward" description="Reference to Material that is valid for this depth range."/>
    </ECEntityClass>

    <ECRelationshipClass typeName="MaterialDepthRangeHasMaterial" strength="referencing" modifier="Sealed" description="Relationship to define that a MaterialDepthRange has a material of Material.">
        <Source multiplicity="(0..*)" roleLabel="has material" polymorphic="false">
            <Class class="MaterialDepthRange" />
        </Source>
        <Target multiplicity="(1..1)" roleLabel="is material for" polymorphic="true"> <!-- left polymorphic for expected future change to IMaterial or similar -->
            <Class class="IMaterial"/>
        </Target>
    </ECRelationshipClass>

    <ECRelationshipClass typeName="BoreholeOwnsMaterialDepthRanges" strength="embedding" modifier="Sealed">
        <BaseClass>bis:ElementOwnsChildElements</BaseClass>
        <Source multiplicity="(1..1)" polymorphic="false" roleLabel="owns">
            <Class class="Borehole"/>
        </Source>
        <Target multiplicity="(0..*)" polymorphic="false" roleLabel="is owned by">
            <Class class="MaterialDepthRange"/>
        </Target>
    </ECRelationshipClass>

    <!-- Note that WaterTableDepth is NOT an IOperand (Borehole should be used as the IOperand instead) -->
    <ECEntityClass typeName="WaterTableDepth" modifier="Sealed" displayLabel="Water Table Depth" description="A location down a Borehole defining the border of saturated and unsaturated soil.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>

        <ECProperty propertyName="Location" typeName="point3d" displayLabel="Location"   kindOfQuantity="AECU:LENGTH" description="The location this WaterTableDepth (along the parent Borehole path)."/>
        <ECProperty propertyName="Depth"    typeName="double"  displayLabel="Top Depth"  kindOfQuantity="AECU:LENGTH" description="Distance from ground surface to water table." />
    </ECEntityClass>

    <ECRelationshipClass typeName="BoreholeOwnsWaterTableDepths" strength="embedding" modifier="Sealed">
        <BaseClass>bis:ElementOwnsChildElements</BaseClass>
        <Source multiplicity="(1..1)" polymorphic="false" roleLabel="owns">
            <Class class="Borehole"/>
        </Source>
        <Target multiplicity="(0..*)" polymorphic="false" roleLabel="is owned by">
            <Class class="WaterTableDepth"/>
        </Target>
    </ECRelationshipClass>

    <!-- ==================== GEOMETRIC MIX-INS ================================== -->
    
    <ECEntityClass typeName="ISurface" modifier="Abstract" displayLabel="Surface" description="An interface that defines an IIOperand that contains a surface.">
        <ECCustomAttributes>
            <IsMixin xmlns="CoreCustomAttributes.01.00.03">
                <AppliesToEntityClass>GeotechnicalInterpretationElement</AppliesToEntityClass>
            </IsMixin>
        </ECCustomAttributes>
        <BaseClass>IOperand</BaseClass>

        <!-- NEED TO ADD EXTENDED TYPE extendedTypeName="GeometryFlatBuffer" or sim --> 
        <ECProperty propertyName="Surface" displayLabel="Surface" typeName="binary" description="Contiguous IndexedPolyface defining the geometry of the surface. May be closed."/>
    </ECEntityClass>

    <!-- 
    <ECEntityClass typeName="IVolume" modifier="Abstract" displayLabel="Volume" description="An interface that defines an IIOperand that contains a volume.">
        <ECCustomAttributes>
            <IsMixin xmlns="CoreCustomAttributes.01.00.03">
                <AppliesToEntityClass>GeotechnicalInterpretationElement</AppliesToEntityClass>
            </IsMixin>
        </ECCustomAttributes>
        <BaseClass>IOperand</BaseClass>

        < !- - NEED TO ADD EXTENDED TYPE extendedTypeName="GeometryFlatBuffer" or sim - - > 
        <ECProperty propertyName="Volume" displayLabel="Volume" typeName="binary" description="Contiguous IndexedPolyface defining the geometry of the volume."/>
    </ECEntityClass>
  -->
    <!-- ==================== Terrain Classes ================================== -->
    
    <ECEntityClass typeName="ITerrain" modifier="Abstract" displayLabel="Terrain" description="An interface that marks a class as defining terrain (ground level).">
        <ECCustomAttributes>
            <IsMixin xmlns="CoreCustomAttributes.01.00.03">
                <AppliesToEntityClass>GeotechnicalInterpretationElement</AppliesToEntityClass>
            </IsMixin>
        </ECCustomAttributes>
        <BaseClass>IOperand</BaseClass>
    </ECEntityClass>

    </ECEntityClass>
        <ECEntityClass typeName="TerrainSurface" modifier="Sealed" displayLabel="Terrain Surface" description="An ITerrain that uses a surface (IndexedPolyface) to approximate ground level.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <BaseClass>ITerrain</BaseClass>
        <BaseClass>ISurface</BaseClass>

    </ECEntityClass>

    <!-- ==================== Subsurface RELATED CLASSES ============================== -->


    <!-- NEED TO DETERMINE IF THIS IS ISUBMODELED OR NOT (currently coded as child elements) -->
    <ECEntityClass typeName="Subsurface" modifier="Sealed" displayLabel="Subsurface" description="A approximation of the structure of the ground at surface level and below.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <BaseClass>IOperand</BaseClass>

    </ECEntityClass>

    <!-- Blocks are always children of Subsurface -->
    <ECRelationshipClass typeName="SubsurfaceOwnsBlocks" strength="embedding" modifier="Sealed">
        <BaseClass>bis:ElementOwnsChildElements</BaseClass>
        <Source multiplicity="(1..1)" polymorphic="false" roleLabel="owns">
            <Class class="Subsurface"/>
        </Source>
        <Target multiplicity="(0..*)" polymorphic="false" roleLabel="is owned by">
            <Class class="Block"/>
        </Target>
    </ECRelationshipClass>

    <!-- Boundaries are always children of Subsurface -->
    <ECRelationshipClass typeName="SubsurfaceOwnsBoundaries" strength="embedding" modifier="Sealed">
        <BaseClass>bis:ElementOwnsChildElements</BaseClass>
        <Source multiplicity="(1..1)" polymorphic="false" roleLabel="owns">
            <Class class="Subsurface"/>
        </Source>
        <Target multiplicity="(0..*)" polymorphic="false" roleLabel="is owned by">
            <Class class="Boundary"/>
        </Target>
    </ECRelationshipClass>

    <ECEntityClass typeName="Volume" modifier="Abstract" displayLabel="Volume" description="A contiguous 3D volume that is bounded by Boundaries.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <!-- NEED TO DETERMINE IF THIS IS SHOULD BE AN IVOLUME -->

        <!-- NEED TO ADD EXTENDED TYPE extendedTypeName="GeometryFlatBuffer" or sim --> 
        <ECProperty propertyName="Volume" displayLabel="Volume" typeName="binary" description="An IndexedPolyface that defines a cache of the geometry of the 3D volume."/>
    </ECEntityClass>

    <!-- We need to determine our strategy for handling complex results before we can determine if
        Boundary should be an ISurface or should just have a Surface property -->
    <ECEntityClass typeName="Boundary" modifier="Sealed" displayLabel="Boundary" description="A contiguous surface that bounds Volumes. Always a child of Subsurface.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <BaseClass>ISurface</BaseClass>
    </ECEntityClass>
   
    <ECRelationshipClass typeName="BoundaryBoundsVolumes" strength="referencing" modifier="Abstract" description="Relationship to define the Volume is bounded by the Boundary.">
        <BaseClass>bis:ElementRefersToElements</BaseClass>
        <!-- A Volume must be bounded by as least one Boundary, but we can't use the 1..* constraint as each subclass is 0..*-->
        <Source multiplicity="(0..*)" roleLabel="bounds" polymorphic="false">
            <Class class="Boundary" />
        </Source>
        <!-- A Boundary must bound as least one Volume, but we can't use the 1..2 constraint as each subclass is 0..1-->
        <Target multiplicity="(0..2)" roleLabel="is bounded by" polymorphic="true">
            <Class class="Volume"/>
        </Target>
    </ECRelationshipClass>

    <ECRelationshipClass typeName="BoundaryBoundsVolumeOnPositiveSide" strength="referencing" modifier="Sealed" description="Relationship to define the Volume is bounded by the positive side of the Boundary.">
        <BaseClass>BoundaryBoundsVolumes</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="bounds on positive side" polymorphic="false">
            <Class class="Boundary" />
        </Source>
        <Target multiplicity="(0..1)" roleLabel="is bounded by positive side of" polymorphic="true">
            <Class class="Volume"/>
        </Target>
    </ECRelationshipClass>

    <ECRelationshipClass typeName="BoundaryBoundsVolumeOnNegativeSide" strength="referencing" modifier="Sealed" description="Relationship to define the Volume is bounded by the negative side of the Boundary.">
        <BaseClass>BoundaryBoundsVolumes</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="bounds on negative side" polymorphic="false">
            <Class class="Boundary" />
        </Source>
        <Target multiplicity="(0..1)" roleLabel="is bounded by negative side of" polymorphic="true">
            <Class class="Volume"/>
        </Target>
    </ECRelationshipClass>

    <ECEntityClass typeName="Block" modifier="Sealed" displayLabel="Block" description="A fault block or similar region of consistent Stratums. Always child of Subsurface.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>

    </ECEntityClass>

    <!-- Stratums are always children of Blocks -->
    <ECRelationshipClass typeName="BlockOwnsStratums" strength="embedding" modifier="Sealed">
        <BaseClass>bis:ElementOwnsChildElements</BaseClass>
        <Source multiplicity="(1..1)" polymorphic="false" roleLabel="owns">
            <Class class="Block"/>
        </Source>
        <Target multiplicity="(0..*)" polymorphic="false" roleLabel="is owned by">
            <Class class="Stratum"/>
        </Target>
    </ECRelationshipClass>

    <!-- WaterTables are always children of Blocks -->
    <ECRelationshipClass typeName="BlockOwnsWaterTables" strength="embedding" modifier="Sealed">
        <BaseClass>bis:ElementOwnsChildElements</BaseClass>
        <Source multiplicity="(1..1)" polymorphic="false" roleLabel="owns">
            <Class class="Block"/>
        </Source>
        <Target multiplicity="(0..*)" polymorphic="false" roleLabel="is owned by">
            <Class class="WaterTable"/>
        </Target>
    </ECRelationshipClass>

     <ECEntityClass typeName="Stratum" modifier="Sealed" displayLabel="Stratum" description="A Volume representing a stratum of constant material. Always child of Block.">
        <BaseClass>Volume</BaseClass>

        <ECNavigationProperty propertyName="Material" relationshipName="StratumHasMaterial" direction="Forward" description="Reference to IMaterial of the Stratum (required)."/>
    </ECEntityClass>
   
     <ECRelationshipClass typeName="StratumHasMaterial" strength="referencing" modifier="Sealed" description="Relationship to define that a Stratum has a material of Material.">
        <Source multiplicity="(0..*)" roleLabel="has material" polymorphic="false">
            <Class class="Stratum" />
        </Source>
        <Target multiplicity="(1..1)" roleLabel="is material for" polymorphic="true">
            <Class class="Material"/> <!-- need to change to IMaterial after merge -->
        </Target>
    </ECRelationshipClass>
 
     <ECEntityClass typeName="WaterTable" modifier="Sealed" displayLabel="Water Table" description="A border between saturated and unsaturated soil. Always child of Block.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>

        <!-- NEED TO ADD EXTENDED TYPE extendedTypeName="GeometryFlatBuffer" or sim --> 
        <ECProperty propertyName="Surface" displayLabel="Surface" typeName="binary" description="Contiguous surface defining the geometry of the WaterTable. May be closed."/>
    </ECEntityClass>
   
    <!-- ==================== SubsurfaceGeneration RELATED CLASSES ==================== -->

    <!-- This is mostly a placeholder for now -->
    <ECEntityClass typeName="SubsurfaceGeneration" modifier="Sealed" displayLabel="Subsurface Generation" description="An Operation that generates a Subsurface from IBoreholeCollections.">
        <BaseClass>Operation</BaseClass>

    </ECEntityClass>

    <ECRelationshipClass typeName="SubsurfaceGenerationHasBoreholeCollectionInput" strength="referencing" modifier="Sealed" description="Connects an SubsurfaceGeneration with its input IBoreholeCollections.">
        <BaseClass>OperationHasInput</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="has input" polymorphic="false">
            <Class class="SubsurfaceGeneration" />
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is input for" polymorphic="true">
            <Class class="IBoreholeCollection" />
        </Target>
    </ECRelationshipClass>

    <ECRelationshipClass typeName="SubsurfaceGenerationHasTerrainSurfaceInput" strength="referencing" modifier="Sealed" description="Connects an SubsurfaceGeneration with its input IBoreholeCollections.">
        <BaseClass>OperationHasInput</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="has input" polymorphic="false">
            <Class class="SubsurfaceGeneration" />
        </Source>
        <!-- NEED TO DETERMINE IF MORE THAN 1 TERRAINSURFACE CAN BE USED FOR INPUT TO A SINGLE GENERATION-->
        <Target multiplicity="(0..*)" roleLabel="is input for" polymorphic="true">
            <Class class="TerrainSurface" />
        </Target>
    </ECRelationshipClass>

    <ECRelationshipClass typeName="SubsurfaceGenerationHasSubsurfaceOutput" strength="referencing" modifier="Sealed" description="Connects an SubsurfaceGeneration with its output Subsurface.">
        <BaseClass>OperationHasOutput</BaseClass>
        <!-- Every Subsurface must have come from a generation operation-->
        <Source multiplicity="(1..1)" roleLabel="has output" polymorphic="false">
            <Class class="SubsurfaceGeneration" />
        </Source>
        <!-- before Operation is run there will not be any Subsurface-->
        <Target multiplicity="(0..1)" roleLabel="is output for" polymorphic="false">
            <Class class="Subsurface" />
        </Target>
    </ECRelationshipClass>

    <!-- ==================== CORE OPERATION/OPERAND SYSTEM ==================== -->

    <ECEntityClass typeName="IOperand" modifier="Abstract" displayLabel="IOperand" description="Element which can be used as input to an Operation and/or may be output from an Operation.">
        <ECCustomAttributes>
            <IsMixin xmlns="CoreCustomAttributes.01.00.00">
                <AppliesToEntityClass>bis:Element</AppliesToEntityClass>
            </IsMixin>
        </ECCustomAttributes>
    </ECEntityClass>

    <ECEntityClass typeName="Operation" modifier="Abstract" displayLabel="Operation" description="Abstract superclass for an operation that takes IOperand inputs and produces an IOperand results.">
        <BaseClass>GeotechnicalInformationElement</BaseClass>
    </ECEntityClass>

    <ECRelationshipClass typeName="OperationHasInput" strength="referencing" modifier="Abstract" description="Connects an Operation with its input IOperands.">
        <BaseClass>bis:ElementRefersToElements</BaseClass>
        <!-- IOperand may be input for 0, 1 or many Operations-->
        <Source multiplicity="(0..*)" roleLabel="has input" polymorphic="true">
            <Class class="Operation" />
        </Source>
        <!-- While an Operation always requires input, some subclasses of this relationship may have optional input, so we need to have 0..* cardinality below-->
        <Target multiplicity="(0..*)" roleLabel="is input for" polymorphic="true">
            <Class class="IOperand" />
        </Target>
    </ECRelationshipClass>

    <!-- TBD: Should result IOperands be children of the Operation? That would enforce cascading delete behavior (appropriately). -->
    <!-- TBD: If so, this needs to be a subclass of ElementOwnsChildElements. -->
    <!-- TBD: Can an Operation have more than 1 result IOperand? How do we handle complex output? -->
    <ECRelationshipClass typeName="OperationHasOutput" strength="referencing" modifier="Abstract" description="Connects an Operation with its output IOperands.">
        <BaseClass>bis:ElementRefersToElements</BaseClass>
        <!-- IOperand can be result of 0 Operations (if it is "pure input") or 1 Operation if it is a result-->
        <Source multiplicity="(0..1)" roleLabel="has output" polymorphic="true"> 
            <Class class="Operation" />
        </Source>
        <!-- Operation usually has 1 IOperand result, but won't if it hasn't been run -->
        <Target multiplicity="(0..1)" roleLabel="is output of" polymorphic="true"> 
            <Class class="IOperand" />
        </Target>
    </ECRelationshipClass>

    <!-- IOperand Classes -->

    <ECEntityClass typeName="OperationParameters" modifier="Abstract" displayLabel="OperationParameters" description="Parameters that are related to an Operation and are conceptually part of the Operation.">
        <BaseClass>GeotechnicalInformationElement</BaseClass>
        <BaseClass>IOperand</BaseClass>
    </ECEntityClass>

    <!-- ==================== FOR TEMPORARY PERFORMANCE TESTING ONLY ==================== -->

    <ECEntityClass typeName="TestSurface" modifier="Abstract" displayLabel="Test Element with Surface Mesh" description="For testing purposes only.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <!-- NEED TO ADD EXTENDED TYPE extendedTypeName="GeometryFlatBuffer" or sim -->        
        <ECProperty propertyName="Surface" displayLabel="Surface" typeName="binary" description="For testing surface meshes."/>
    </ECEntityClass>

    <ECEntityClass typeName="TestVolume" modifier="Abstract" displayLabel="Test Element with BREP Volume" description="For testing purposes only.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <!-- NEED TO ADD EXTENDED TYPE extendedTypeName="GeometryFlatBuffer" or sim --> 
        <ECProperty propertyName="Volume" displayLabel="Volume" typeName="binary" description="For testing BREP volume performance/strategy."/>
    </ECEntityClass>

</ECSchema>