<?xml version="1.0" encoding="UTF-8"?>
<ECSchema schemaName="GeotechnicalInterpretation" alias="GeoInterp" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2" displayLabel="Geotechnical Interpretation" description="The GeotechnicalInterpretation schema defines classes that represent data for interpreting the earth's subterranean structure based on limited geotechnical exploration.">
    <ECSchemaReference name="AecUnits" version="01.00.03" alias="AECU"/>
    <ECSchemaReference name="Analytical" version="01.00.00" alias="anlyt" />
    <ECSchemaReference name="BisCore" version="01.00.10" alias="bis" />
    <ECSchemaReference name="CoreCustomAttributes" version="01.00.03" alias="CoreCA"/>
    <ECSchemaReference name="GeotechnicalExploration" version="01.00.00" alias="GeoExp" />

    <ECCustomAttributes>
        <ProductionStatus xmlns="CoreCustomAttributes.01.00.03">
            <SupportedUse>NotForProduction</SupportedUse>
        </ProductionStatus>
    </ECCustomAttributes>

    <!-- ==================== CORE INFORMATION HIERARCHY CLASSES ==================== -->

    <ECEntityClass typeName="GeotechnicalInterpretationPartition" modifier="Sealed" displayLabel="Geotechnical Interpretation Partition" description="GeotechnicalInterpretationPartition element indicates that there is a specialized Geotechnical Interpretation perspective for the parent Subject. " >
        <BaseClass>anlyt:AnalyticalPartition</BaseClass>
    </ECEntityClass>

    <ECEntityClass typeName="GeotechnicalInterpretationModel" modifier="Sealed" displayLabel="Geotechnical Interpretation Model" description="Model containing elements related to Geotechnical Interpretations." >
        <BaseClass>anlyt:AnalyticalModel</BaseClass>
    </ECEntityClass>

    <ECEntityClass typeName="GeotechnicalInterpretationElement" modifier="Abstract" displayLabel="Geotechnical Interpretation Element" description="Abstract superclass for all spatially-located Geotechnical Interpretation classes.">
        <BaseClass>anlyt:AnalyticalElement</BaseClass>
    </ECEntityClass>

    <ECEntityClass typeName="GeotechnicalInformationElement" modifier="Abstract" displayLabel="Geotechnical Information Element" description="Abstract superclass for all non-spatially-located Geotechnical Interpretation classes.">
        <BaseClass>bis:InformationRecordElement</BaseClass>
    </ECEntityClass>

    <ECEntityClass typeName="Interpretation" modifier="Sealed" displayLabel="Interpretation" description="A geotechnical interpretation of a region of the earth's subsurface. Interpretations always have a GeotechnicalInterpretationModel submodel.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <BaseClass>bis:ISubModeledElement</BaseClass>

        <ECNavigationProperty propertyName="Configuration" relationshipName="InterpretationHasConfiguration" direction="Forward" description="Reference to GeotechnicalInterpretationConfiguration that is used by this Interpretation."/>

        <!-- Add Bounds? -->
    </ECEntityClass>


    <!-- ==================== CONFIGURATION (DEFINITION MODEL) RELATED CLASSES ==================== -->

    <ECEntityClass typeName="GeotechnicalInterpretationConfiguration" modifier="Sealed" displayLabel="Geotechnical Interpretation Configuration" description="The configuration for one or more GeoExp:Interpretation.">
        <BaseClass>Bis:DefinitionContainer</BaseClass>
    </ECEntityClass>

    <ECRelationshipClass typeName="InterpretationHasConfiguration" strength="referencing" modifier="Sealed" description="Relationship to define that a specific GeoInterp:Interpretation has a configuration of GeoInterp:GeotechnicalInterpretationConfiguration.">
        <Source multiplicity="(0..*)" roleLabel="has configuration" polymorphic="true">
            <Class class="Interpretation" />
        </Source>
        <Target multiplicity="(1..1)" roleLabel="is configuration for" polymorphic="true">
            <Class class="GeotechnicalInterpretationConfiguration"/>
        </Target>
    </ECRelationshipClass>

    <ECEntityClass typeName="InvestigationMapping" displayLabel="Investigation Mapping" modifier="Sealed" description="A mapping from a GeoExp:GeotechnicalInvestigationConfiguration to a GeoInterp:GeotechnicalInterpretationConfiguration.">
        <BaseClass>bis:DefinitionElement</BaseClass>   
        <ECProperty           propertyName="MaterialMappedClass"     typeName="string" displayLabel="Material Mapped Class"   description="Identifies the GeoExp:ILithology subclass that maps to GeoInterp:Material"/>

        <ECNavigationProperty propertyName="MappedConfiguration"    relationshipName="InvestigationMappingMapsInvestigationConfiguration"   direction="Forward" description="Reference to GeoExp:GeotechnicalInvestigationConfiguration that is being mapped."/>
   </ECEntityClass>

    <ECRelationshipClass typeName="InvestigationMappingMapsInvestigationConfiguration" strength="referencing" modifier="Sealed" description="Relationship to define that a specific GeoInterp:InvestigationMapping maps a GeoExp:GeotechnicalInvestigationConfiguration.">
        <Source multiplicity="(0..*)" roleLabel="maps" polymorphic="true">
            <Class class="InvestigationMapping" />
        </Source>
        <Target multiplicity="(1..1)" roleLabel="is mapped by" polymorphic="true">
            <Class class="GeoExp:GeotechnicalInvestigationConfiguration"/>
        </Target>
    </ECRelationshipClass>

    <ECEntityClass typeName="Material" displayLabel="Material" modifier="None" description="A geotechnical material, uniform for the purposes of the interpretation.">
        <BaseClass>bis:DefinitionElement</BaseClass>   
    </ECEntityClass>

    <!-- Abstract Material Mapping Relationship (in case we need it) -->
    <ECRelationshipClass typeName="LithologyMapsToMaterial" strength="referencing" modifier="Abstract" description="Maps GeoExp:ILithology to the GeoInterp:Material that represents that material." >
        <BaseClass>bis:ElementRefersToElements</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="maps to" polymorphic="true">
            <!-- Will change this to GeoExp:ILithology later -->
            <Class class="bis:DefinitionElement"/>
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is mapped to" polymorphic="true">
            <Class class="Material"/>
        </Target>
    </ECRelationshipClass>

    <!-- LegendCode-to-Material Mapping -->
    <ECRelationshipClass typeName="LegendCodeMapsToMaterial" strength="referencing" modifier="Sealed" description="Maps a GeoExp:LegendCode to a GeoInterp:Material." >
        <BaseClass>LithologyMapsToMaterial</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="maps to" polymorphic="true">
            <Class class="GeoExp:LegendCode"/>
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is mapped to" polymorphic="true">
            <Class class="Material"/>
        </Target>
    </ECRelationshipClass>

    <!-- UscsCode-to-Material Mapping -->
    <!-- TBD -->

    <!-- GeologyCode-to-Material Mapping -->
    <ECRelationshipClass typeName="GeologyCodeMapsToMaterial" strength="referencing" modifier="Sealed" description="Maps a GeoExp:GeologyCode to a GeoInterp:Material." >
        <BaseClass>LithologyMapsToMaterial</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="maps to" polymorphic="true">
            <Class class="GeoExp:GeologyCode"/>
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is mapped to" polymorphic="true">
            <Class class="Material"/>
        </Target>
    </ECRelationshipClass>


    <!-- AlternateGeologyCode-to-Material Mapping -->
    <ECRelationshipClass typeName="AlternateGeologyCodeMapsToMaterial" strength="referencing" modifier="Sealed" description="Maps a GeoExp:AlternateGeologyCode to a GeoInterp:Material." >
        <BaseClass>LithologyMapsToMaterial</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="maps to" polymorphic="true">
            <Class class="GeoExp:AlternateGeologyCode"/>
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is mapped to" polymorphic="true">
            <Class class="Material"/>
        </Target>
    </ECRelationshipClass>

    <!-- ==================== BOREHOLESET-RELATED CLASSES ==================== -->

    <ECEntityClass typeName="BoreholeSet" modifier="Sealed" displayLabel="Borehole Set" description="A set of Boreholes.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <BaseClass>IOperand</BaseClass>

        <ECNavigationProperty propertyName="Source" relationshipName="BoreholeSetHasSourceInvestigation" direction="Forward" description="Optional reference to GeoExp:GeotechnicalInvestigationElement that is source for this BoreholeSet."/>
    </ECEntityClass>

    <!-- Is "represents" the right term? -->
    <ECRelationshipClass typeName="BoreholeSetHasSourceInvestigation" strength="referencing" modifier="None" description="Relates a BoreholeSet to the GeoExp:GeotechnicalInvestigationElement it was derived from.">
        <Source multiplicity="(0..*)" roleLabel="has source" polymorphic="true">
            <Class class="BoreholeSet" />
        </Source>
        <Target multiplicity="(0..1)" roleLabel="is source for" polymorphic="true">
            <Class class="GeoExp:GeotechnicalInvestigationElement" />
        </Target>
    </ECRelationshipClass>

    <!-- KAROLIS - Do you think there is value in having these custom classes? They do allow us to clarify cardinality... -->
    <ECRelationshipClass typeName="BoreholeSetOwnsBorehole" strength="embedding" modifier="Sealed">
        <BaseClass>bis:ElementOwnsChildElements</BaseClass>
        <Source multiplicity="(1..1)" polymorphic="true" roleLabel="owns">
            <Class class="BoreholeSet"/>
        </Source>
        <Target multiplicity="(0..*)" polymorphic="true" roleLabel="is owned by">
            <Class class="Borehole"/>
        </Target>
    </ECRelationshipClass>

    <!-- ==================== BOREHOLE-RELATED CLASSES ==================== -->

    <!-- Note that Borehole is NOT an IOperand (the owning BoreholeSet should be used as the IOperand instead) -->
    <ECEntityClass typeName="Borehole" modifier="Sealed" displayLabel="Borehole" description="A borehole or other investigation producing data similar to borehole logs.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>

        <ECProperty propertyName="Active"   displayLabel="Active"   typeName="bool"                              description="This Borehole should be considered in calculations."/>
        <ECProperty propertyName="Location" displayLabel="Location" typeName="Bentley.Geometry.Common.IGeometry" description="The path of the Borehole from the surface downward."/>

        <ECNavigationProperty propertyName="Source" relationshipName="BoreholeHasSourceExploratoryLocation" direction="Forward" description="Optional reference to GeoExp:ExploratoryLocation that is source for this Borehole."/>
    </ECEntityClass>

    <ECRelationshipClass typeName="BoreholeHasSourceExploratoryLocation" strength="referencing" modifier="Sealed" description="Relates a Borehole to the GeoExp:ExploratoryLocation it was derived from.">
        <Source multiplicity="(0..*)" roleLabel="has source" polymorphic="true">
            <Class class="Borehole" />
        </Source>
        <Target multiplicity="(0..1)" roleLabel="is source for" polymorphic="true">
            <Class class="GeoExp:ExploratoryLocation" />
        </Target>
    </ECRelationshipClass>

    <!-- Note that MaterialDepthRange is NOT an IOperand (Borehole should be used as the IOperand instead) -->
    <ECEntityClass typeName="MaterialDepthRange" modifier="Sealed" displayLabel="Material Depth Range" description="A contiguous portion of a Borehole with a constant Material. Always parented by Borehole.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>

        <ECProperty propertyName="Location"  typeName="Bentley.Geometry.Common.IGeometry" displayLabel="Location"     kindOfQuantity="AECU:LENGTH" description="The location this MaterialDepthRange (portion of the parent Borehole path)."/>
        <ECProperty propertyName="DepthTop"  typeName="double"                            displayLabel="Top Depth"    kindOfQuantity="AECU:LENGTH" description="Distance from ground surface to top of depth range." />
        <ECProperty propertyName="DepthBase" typeName="double"                            displayLabel="Bottom Depth" kindOfQuantity="AECU:LENGTH" description="Distance from ground surface to bottom of depth range."/>

        <ECNavigationProperty propertyName="Material" relationshipName="MaterialDepthRangeHasMaterial" direction="Forward" description="Reference to Material that is valid for this depth range."/>
    </ECEntityClass>

    <ECRelationshipClass typeName="MaterialDepthRangeHasMaterial" strength="referencing" modifier="Sealed" description="Relationship to define that a MaterialDepthRange has a material of Material.">
        <Source multiplicity="(0..*)" roleLabel="has material" polymorphic="true">
            <Class class="MaterialDepthRange" />
        </Source>
        <Target multiplicity="(1..1)" roleLabel="is material for" polymorphic="true">
            <Class class="Material"/>
        </Target>
    </ECRelationshipClass>

    <!-- KAROLIS - Do you think there is value in having these custom classes? They do allow us to clarify cardinality... -->
    <ECRelationshipClass typeName="BoreholeOwnsMaterialDepthRange" strength="embedding" modifier="Sealed">
        <BaseClass>bis:ElementOwnsChildElements</BaseClass>
        <Source multiplicity="(1..1)" polymorphic="true" roleLabel="owns">
            <Class class="Borehole"/>
        </Source>
        <Target multiplicity="(0..*)" polymorphic="true" roleLabel="is owned by">
            <Class class="MaterialDepthRange"/>
        </Target>
    </ECRelationshipClass>

    <!-- Note that WaterTableDepth is NOT an IOperand (Borehole should be used as the IOperand instead) -->
    <ECEntityClass typeName="WaterTableDepth" modifier="Sealed" displayLabel="Water Table Depth" description="A location down a Borehole defining the border of saturated and unsaturated soil.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>

        <ECProperty propertyName="Location" typeName="point3d" displayLabel="Location"   kindOfQuantity="AECU:LENGTH" description="The location this WaterTableDepth (along the parent Borehole path)."/>
        <ECProperty propertyName="Depth"    typeName="double"  displayLabel="Top Depth"  kindOfQuantity="AECU:LENGTH" description="Distance from ground surface to water table." />
    </ECEntityClass>

    <!-- KAROLIS - Do you think there is value in having these custom classes? They do allow us to clarify cardinality... -->
    <ECRelationshipClass typeName="BoreholeOwnsWaterTableDepth" strength="embedding" modifier="Sealed">
        <BaseClass>bis:ElementOwnsChildElements</BaseClass>
        <Source multiplicity="(1..1)" polymorphic="true" roleLabel="owns">
            <Class class="Borehole"/>
        </Source>
        <Target multiplicity="(0..*)" polymorphic="true" roleLabel="is owned by">
            <Class class="WaterTableDepth"/>
        </Target>
    </ECRelationshipClass>

    <!-- ==================== SUBSURFACE RELATED CLASSES ==================== -->

    <!-- This is mostly a placeholder for now -->
    <ECEntityClass typeName="Subsurface" modifier="Sealed" displayLabel="Subsurface" description="A approximation of the structure of the ground at surface level and below.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <BaseClass>IOperand</BaseClass>

    </ECEntityClass>

    <!-- ==================== SUBSURFACEGENERATION RELATED CLASSES ==================== -->

    <!-- This is mostly a placeholder for now -->
    <ECEntityClass typeName="SubsurfaceGeneration" modifier="Sealed" displayLabel="Subsurface Generation" description="An Operation that generates a Subsurface from BoreholeSets.">
        <BaseClass>Operation</BaseClass>

    </ECEntityClass>

    <ECRelationshipClass typeName="SubsurfaceGenerationHasBoreholeSetInput" strength="referencing" modifier="Sealed" description="Connects an SubsurfaceGeneration with its input BoreholeSets.">
        <BaseClass>OperationHasInput</BaseClass>
        <Source multiplicity="(0..*)" roleLabel="has input" polymorphic="true">
            <Class class="SubsurfaceGeneration" />
        </Source>
        <Target multiplicity="(0..*)" roleLabel="is input for" polymorphic="true">
            <Class class="BoreholeSet" />
        </Target>
    </ECRelationshipClass>

    <ECRelationshipClass typeName="SubsurfaceGenerationHasSubsurfaceOutput" strength="referencing" modifier="Sealed" description="Connects an SubsurfaceGeneration with its output Subsurface.">
        <BaseClass>OperationHasOutput</BaseClass>
        <!-- Every Subsurface must have come from a generation operation-->
        <Source multiplicity="(1..1)" roleLabel="has output" polymorphic="true">
            <Class class="SubsurfaceGeneration" />
        </Source>
        <!-- before Operation is run there will not be any Subsurface-->
        <Target multiplicity="(0..1)" roleLabel="is output for" polymorphic="true">
            <Class class="Subsurface" />
        </Target>
    </ECRelationshipClass>

    <!-- ==================== CORE OPERATION/OPERAND SYSTEM ==================== -->

    <ECEntityClass typeName="IOperand" modifier="Abstract" displayLabel="IOperand" description="Element which can be used as input to an Operation and/or may be output from an Operation.">
        <ECCustomAttributes>
            <IsMixin xmlns="CoreCustomAttributes.01.00.00">
                <AppliesToEntityClass>bis:Element</AppliesToEntityClass>
            </IsMixin>
        </ECCustomAttributes>
    </ECEntityClass>

    <ECEntityClass typeName="Operation" modifier="Abstract" displayLabel="Operation" description="Abstract superclass for an operation that takes IOperand inputs and produces an IOperand results.">
        <BaseClass>GeotechnicalInformationElement</BaseClass>
    </ECEntityClass>

    <ECRelationshipClass typeName="OperationHasInput" strength="referencing" modifier="Abstract" description="Connects an Operation with its input IOperands.">
        <BaseClass>bis:ElementRefersToElements</BaseClass>
        <!-- IOperand may be input for 0, 1 or many Operations-->
        <Source multiplicity="(0..*)" roleLabel="has input" polymorphic="true">
            <Class class="Operation" />
        </Source>
        <!-- While an Operation always requires input, some subclasses of this relationship may have optional input, so we need to have 0..* cardinality below-->
        <Target multiplicity="(0..*)" roleLabel="is input for" polymorphic="true">
            <Class class="IOperand" />
        </Target>
    </ECRelationshipClass>

    <!-- TBD: Should result IOperands be children of the Operation? That would enforce cascading delete behavior (appropriately). -->
    <!-- TBD: If so, this needs to be a subclass of ElementOwnsChildElements. -->
    <!-- TBD: Can an Operation have more than 1 result IOperand? How do we handle complex output? -->
    <ECRelationshipClass typeName="OperationHasOutput" strength="referencing" modifier="Abstract" description="Connects an Operation with its output IOperands.">
        <BaseClass>bis:ElementRefersToElements</BaseClass>
        <!-- IOperand can be result of 0 Operations (if it is "pure input") or 1 Operation if it is a result-->
        <Source multiplicity="(0..1)" roleLabel="has output" polymorphic="true"> 
            <Class class="Operation" />
        </Source>
        <!-- Operation usually has 1 IOperand result, but won't if it hasn't been run -->
        <Target multiplicity="(0..1)" roleLabel="is output of" polymorphic="true"> 
            <Class class="IOperand" />
        </Target>
    </ECRelationshipClass>

    <!-- IOperand Classes -->

    <ECEntityClass typeName="OperationParameters" modifier="Abstract" displayLabel="OperationParameters" description="Parameters that are related to an Operation and are conceptually part of the Operation.">
        <BaseClass>GeotechnicalInformationElement</BaseClass>
        <BaseClass>IOperand</BaseClass>
    </ECEntityClass>


    <!-- ==================== FOR TEMPORARY PERFORMANCE TESTING ONLY ==================== -->

    <ECEntityClass typeName="TestSurface" modifier="Abstract" displayLabel="Test Element with Surface Mesh" description="For testing purposes only.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <ECProperty propertyName="Surface" displayLabel="Surface" typeName="Bentley.Geometry.Common.IGeometry"  description="For testing surface meshes."/>
    </ECEntityClass>

    <ECEntityClass typeName="TestVolume" modifier="Abstract" displayLabel="Test Element with BREP Volume" description="For testing purposes only.">
        <BaseClass>GeotechnicalInterpretationElement</BaseClass>
        <ECProperty propertyName="Volume" displayLabel="Volume" typeName="Bentley.Geometry.Common.IGeometry"  description="For testing BREP volume performance/strategy."/>
    </ECEntityClass>

</ECSchema>