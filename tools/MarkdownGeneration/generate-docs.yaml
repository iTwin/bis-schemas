workspace:
  clean: all

trigger:
  branches:
    include:
     - master
  paths:
    include:
     - 'Domains/'
     - 'Standard/'

pool:
  name: iModelTechCI
  demands:
  - Agent.OS -equals Windows_NT
  - npm

variables:
- group: 
- name: ECObjectsToolsPath
  value: '$(Build.BinariesDirectory)\ECObjectsToolsNuGet_x64'

steps:
- task: NuGetCommand@2
  displayName: Install ECObjects Tools
  inputs:
    command: custom
    arguments: install ECObjectsToolsNuGet_x64 -ExcludeVersion -Source _packaging/Packages/nuget/v3/index.json -OutputDirectory $(Build.BinariesDirectory)

#Your build pipeline references a secret variable named ‘’. This variable is pulled from the '' variable group.  You must authorize this build to use that group: https://docs.microsoft.com/en-us/azure/devops/pipelines/library/variable-groups?view=azure-devops&tabs=yaml#use-a-variable-group
- powershell: |
    $npmrcDir = "$(Build.Repository.LocalPath)"
    
    if(!(Test-Path -Path $npmrcDir)){
        mkdir $npmrcDir
    }
    
    $npmrcFile = $npmrcDir + "/.npmrc"
    
    Out-File -FilePath $npmrcFile -Encoding ascii -InputObject "@bentley:registry=/"
    
    Out-File -FilePath $npmrcFile -Encoding ascii -InputObject "////_packaging/Packages/npm/registry/:username=Packages" -Append
    Out-File -FilePath $npmrcFile -Encoding ascii -InputObject "////_packaging/Packages/npm/registry/:_password=$()" -Append
    Out-File -FilePath $npmrcFile -Encoding ascii -InputObject "////_packaging/Packages/npm/registry/:email=npm requires email to be set but doesn't use the value" -Append
    Out-File -FilePath $npmrcFile -Encoding ascii -InputObject "////_packaging/Packages/npm/:username=Packages" -Append
    Out-File -FilePath $npmrcFile -Encoding ascii -InputObject "////_packaging/Packages/npm/:_password=$()" -Append
    Out-File -FilePath $npmrcFile -Encoding ascii -InputObject "////_packaging/Packages/npm/:email=npm requires email to be set but doesn't use the value" -Append

- script: npm install @bentley/ecjson2md@latest
  displayName: Install ECJson2md
  workingDirectory: $(Build.BinariesDirectory)

- task: CopyFiles@2
  displayName: 'Copy all schemas to staging directory'
  inputs:
    SourceFolder: '$(System.DefaultWorkingDirectory)'
    Contents: '**/*.ecschema.xml'
    TargetFolder: '$(Build.StagingDirectory)\xml\'

- task: PythonScript@0
  displayName: Run Schema Json Serializer
  inputs:
    scriptSource: inline
    script: |
     import os, sys, shutil, subprocess
     from sets import Set

     defaultWorkingDir = os.path.realpath(sys.argv[1])

     schemasToSkip = ["ECDbFileInfo", "ECDbSystem", "ECv3ConversionAttributes", "PresentationRules", "SchemaLocalizationCustomAttributes", "CifBridge", "CifCommon", "CifGeometricRules", "CifHydraulicAnalysis", "CifHydraulicResults", "CifQuantityTakeoffs", "CifRoads", "CifSubsurface", "CifSubsurfaceConflictAnalysis", "CifUnits"]
     # folders that contain a schema but aren't a released folder as reference directories.
     refDir = Set()
     # all released schemas found by looking in 'Released' directories and pulling the highest schema version
     releasedSchemas = {}
     # files found in 'media' directories that do not end with .cmap
     schemaMediaFiles = Set()
     for root, dirs, files in os.walk(defaultWorkingDir):
       files.sort(reverse=True)
       for fileName in files:
         # reference schema directories
         if "Released" not in root and fileName.endswith(".ecschema.xml"):
           refDir.add(root)
           print "Added directory " + root + " as a reference path."
         # Relesed schema Files
         if "Released" in root and fileName.endswith(".ecschema.xml"):
           schemaName = fileName[:fileName.index(".")]
           if schemaName not in releasedSchemas and schemaName not in schemasToSkip:
             releasedSchemas[schemaName] = os.path.join(root, fileName)
             print "Added released schema " + fileName + " from directory " + root
         # media files
         if "media" in root and "docs" not in root and not fileName.endswith(".cmap"):
           schemaMediaFiles.add(os.path.join(root, fileName))
           print "Added media for schema " + fileName + " from directory " + root

     # add the released versions of the ECDb schemas because the real versions are not copied over
     refDir.add(os.path.join(defaultWorkingDir, "Standard", "ECDb", "Released"))
     rDir = ' '.join(refDir)

     schemaSerializer = os.path.realpath(sys.argv[2])
     print "Using the schema json serializer, '" + schemaSerializer + "'."

     outputDir = os.path.join(os.path.realpath(sys.argv[3]), "json")
     print "Using the output directory, '" + outputDir + "'."

     args = [
       schemaSerializer,
       "-a",  # Serializes all of the schemas in the Schema Graph
       "-u",  # Inclues the standard schemas in the conversion
       "-r", rDir,  # The reference directories to use to find other schemas
       "-o", outputDir,  # The output directory to place the ECJson schemas
       "-i", # The input file to be serialized to ECJson
     ]

     mdOutputDir = os.path.join(os.path.realpath(sys.argv[3]), "markdown")
     if not os.path.exists(mdOutputDir):
       os.makedirs(mdOutputDir)
     
     for schemaName, fullXmlSchemaPath in releasedSchemas.items():
       args.append(fullXmlSchemaPath)

       print "Serializing the schema path '" + fullXmlSchemaPath+ "'."

       proc = subprocess.Popen(' '.join(args), stdin = subprocess.PIPE, stdout = subprocess.PIPE, shell=True)

       if proc.returncode is not None and proc.returncode != 0:
         print "The serialization left a non-zero exit code: " + str(proc.returncode)
         exit(proc.returncode)

       print "Finished serializing the schema path '" + fullXmlSchemaPath + "'."

       args.pop()

       # Copy all markdown files that also have a schema.
       fullMdSchemaPath = os.path.join(fullXmlSchemaPath[:fullXmlSchemaPath.find("Released")], schemaName) + ".remarks.md"
       if os.path.exists(fullMdSchemaPath):
         print "Copying schema markdown file " + fullMdSchemaPath
         shutil.copy(fullMdSchemaPath, mdOutputDir)

     mdMediaOutputDir = os.path.join(mdOutputDir, "media")
     for mediaFile in schemaMediaFiles:
       targetFilePath = os.path.join(mdMediaOutputDir, mediaFile.split('media\\')[-1])
       if not os.path.exists(os.path.dirname(targetFilePath)):
         os.makedirs(os.path.dirname(targetFilePath))
       if os.path.exists(targetFilePath):
         print "ERROR - Cannot copy " + mediaFile + " because a file with the same name already exists in the media output directory."
         exit(-1)
       print "Copying media file " + mediaFile
       shutil.copy(mediaFile, targetFilePath)

    arguments: '$(System.DefaultWorkingDirectory) $(ECObjectsToolsPath)\lib\native\SchemaJsonSerializer $(Build.StagingDirectory)'

- script: |
   mkdir $(Build.StagingDirectory)\markdown\
   
   cmd | for %%a in ($(Build.StagingDirectory)\json\*.json) do (
     $(Build.BinariesDirectory)/node_modules/.bin/ecjson2md -i %%a -r $(Build.StagingDirectory)\json\ -o $(Build.StagingDirectory)\markdown\
   )
  displayName: 'Generate Markdown'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact: Bis Docs'
  inputs:
    PathtoPublish: '$(Build.StagingDirectory)\markdown\'
    ArtifactName: 'Bis Docs'
